<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Evaluating residuals in higher precision · MultiPrecisionArrays.jl</title><meta name="title" content="Evaluating residuals in higher precision · MultiPrecisionArrays.jl"/><meta property="og:title" content="Evaluating residuals in higher precision · MultiPrecisionArrays.jl"/><meta property="twitter:title" content="Evaluating residuals in higher precision · MultiPrecisionArrays.jl"/><meta name="description" content="Documentation for MultiPrecisionArrays.jl."/><meta property="og:description" content="Documentation for MultiPrecisionArrays.jl."/><meta property="twitter:description" content="Documentation for MultiPrecisionArrays.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MultiPrecisionArrays.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Half Precision and Krylov-IR</span><ul><li><a class="tocitem" href="../../Half_1/">Half Precision and Krylov-IR</a></li></ul></li><li><span class="tocitem">More than you want to know</span><ul><li><a class="tocitem" href="../Termination/">Terminating the while loop</a></li><li><a class="tocitem" href="../N2Work/">Is O(N^2) work negligible?</a></li><li><a class="tocitem" href="../Interprecision_1/">Interprecision Transfers: Part I</a></li><li class="is-active"><a class="tocitem" href>Evaluating residuals in higher precision</a><ul class="internal"><li><a class="tocitem" href="#IR-Krylov-with-high-precision-residuals"><span>IR-Krylov with high precision residuals</span></a></li></ul></li></ul></li><li><span class="tocitem">MPArray Constructors</span><ul><li><a class="tocitem" href="../../functions/MPArray/">MPArray: constructor</a></li><li><a class="tocitem" href="../../functions/MPGArray/">MPGArray: constructor</a></li><li><a class="tocitem" href="../../functions/MPBArray/">MPBArray: constructor</a></li></ul></li><li><span class="tocitem">Factorizations</span><ul><li><a class="tocitem" href="../../functions/hlu!/">hlu!: Get LU to perform reasonably well for Float16</a></li><li><a class="tocitem" href="../../functions/mplu!/">mplu!: Simple MPArray factorization</a></li><li><a class="tocitem" href="../../functions/mplu/">mplu: Combine MPArray construction and factorization</a></li><li><a class="tocitem" href="../../functions/mpglu!/">mpglu!: Factor a MPGArray and set it up for GMRES by allocating room for Krylov vectors etc</a></li><li><a class="tocitem" href="../../functions/mpglu/">mpglu: Combine MPGArray construction and factorization</a></li><li><a class="tocitem" href="../../functions/mpblu!/">mpblu!: Factor a MPBArray and set it up for BiCGSTAB by allocating room for a few vectors</a></li><li><a class="tocitem" href="../../functions/mpblu/">mpblu: Combine MPBArray construction and factorization</a></li></ul></li><li><span class="tocitem">Iteration Statistics</span><ul><li><a class="tocitem" href="../Stats/">Harvesting Iteration Statistics</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../functions/mpgeslir/">mpgeslir: IR solver</a></li><li><a class="tocitem" href="../../functions/mpkrir/">mpkrir: Krylov-IR solver</a></li></ul></li><li><span class="tocitem">Termination</span><ul><li><a class="tocitem" href="../../functions/update_parms/">update_parms: Adjust termination criteria for while loop in IR</a></li></ul></li><li><span class="tocitem">References</span><ul><li><a class="tocitem" href="../../References/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">More than you want to know</a></li><li class="is-active"><a href>Evaluating residuals in higher precision</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Evaluating residuals in higher precision</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ctkelley/MultiPrecisionArrays.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ctkelley/MultiPrecisionArrays.jl/blob/main/docs/src/Details/Extended.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Evaluating-residuals-in-higher-precision"><a class="docs-heading-anchor" href="#Evaluating-residuals-in-higher-precision">Evaluating residuals in higher precision</a><a id="Evaluating-residuals-in-higher-precision-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-residuals-in-higher-precision" title="Permalink"></a></h1><p>This idea comes from (<a href="../../References/#Wilkinson48">Wilkinson, 1948</a>) and I am using the notation from (<a href="../../References/#demmelir">Demmel <em>et al.</em>, 2006</a>) and (<a href="../../References/#amestoy_2024">Amestoy <em>et al.</em>, 2024</a>). The idea is to evaluate the residual in a precision <code>TR</code>  higher than the working precision. If you do this, you should store both the solution and the residual in precision TR and to interprecision transfers on the fly. In that case you are really solving a promoted problem (<a href="../../References/#ctk_irnote">Kelley, 2024</a>)</p><p class="math-container">\[(I_W^R A) x = I_W^R b\]</p><p>and, by driving the residual to a small value can mitigate ill-conditioning to some degree. Here <span>$I_P^Q$</span> is the interprecision transfer from precision <span>$P$</span> to precision <span>$Q$</span>. <strong>MultiPrecisionArrays</strong>   allows you to do this with the multiprecision factorization you get from <code>mplu</code>. </p><p>The classic example is to let <code>TR</code>  and <code>TF</code> be single precision and <code>TR</code> be double. The storage penalty is that you must store two copies of <span>$A$</span>, one for the residual computation and the other for the factorization.</p><p>Here is an example with a badly conditioned matrix. You must tell <code>mplu</code> to factor in the working precision and use the <code>kwargs</code> in <code>mplu</code> to set <code>TR</code>.</p><p>You may not get exactly the same results for this example on different hardware, BLAS, versions of Julia or this package. I am still playing with the termination criteria and the iteration count could grow or shrink as I do that.</p><p>The continuous problem is</p><p class="math-container">\[u - \alpha G u = 1 - alpha x (1 - x)/2\]</p><p>and the solution is <span>$u \equiv 1$</span>. </p><pre><code class="nohighlight hljs">julia&gt; using MultiPrecisionArrays

julia&gt; using MultiPrecisionArrays.Examples

julia&gt; N=4096; alpha=799.0; AD=I - alpha*Gmat(N);

# conditioning is bad

julia&gt; cond(AD,Inf)
2.35899e+05

# Set up the single precision computation
# and use the right side from the integral equation

julia&gt; h=1.0/(N-1); x=collect(0:h:1); bd = 1.0 .- alpha*x.*(1.0 .- x)*.5;

# Solving in double gives the accuracy you&#39;d expect

julia&gt; u=AD\bd;

julia&gt; norm(u .- 1.0)
3.16529e-10

# Now move the problem to single precision

julia&gt; A = Float32.(AD); xe=ones(Float32,N); b=Float32.(bd)

julia&gt; # You can see the ill-conditioning

julia&gt; xs = A\b; norm(xs-xe,Inf)
1.37073e-02

julia&gt; # The solution of the promoted problem is better.

julia&gt; xp = Float64.(A)\Float64.(b); norm(xp-xe,Inf)
1.44238e-04

julia&gt; # Make sure TF is what it needs to be for this example

julia&gt; # Set TR in the call to mplu.

julia&gt; AF = mplu(A; TF=Float32, TR=Float64);

julia&gt; # Use the multiprecision array to solve the problem.

julia&gt; mrout = \(AF, b; reporting=true);

julia&gt; # look at the residual history

julia&gt; mrout.rhist
6-element Vector{Float64}:
 9.88750e+01
 6.38567e-03
 1.24560e-06
 9.55874e-08
 8.49478e-08
 8.49478e-08

julia&gt; # Compare the solution to the solution of the promoted problem

julia&gt; norm(mrout.sol - xp,Inf)
5.95629e-08

julia&gt; # That&#39;s consistent with theory.

juila&gt; # So the solution is ok?

julia&gt; norm(mrout.sol - xe, Inf)
1.44243e-04

julia&gt; # Yes.
</code></pre><p>So, is the solution to the promoted problem better than the exact solution I used to build the problem?</p><p>The reader might try this with <code>TF=Float16</code>, the default when <code>TW = Float32</code>. All that you&#39;ll need to do is replace</p><pre><code class="nohighlight hljs">AF = mplu(A; TF=Float32, TR=Float64);</code></pre><p>with</p><pre><code class="nohighlight hljs">AF = mplu(A; TR=Float64);</code></pre><p>What goes wrong and why? Fixup to follow.</p><p>The advantages of evaluating the residual in extended precision grow when <span>$A$</span> is extremely ill-conditioned. Of course, in this case the factorization in the factorization precision could be so inaccurate that IR will fail to converge. One approach to respond to this, as you might expect, is to use the factorization as a preconditioner and not a solver (<a href="../../References/#amestoy_2024">Amestoy <em>et al.</em>, 2024</a>). We will support this in a later version of <strong>MultiPrecisionArrays.jl</strong>.</p><h2 id="IR-Krylov-with-high-precision-residuals"><a class="docs-heading-anchor" href="#IR-Krylov-with-high-precision-residuals">IR-Krylov with high precision residuals</a><a id="IR-Krylov-with-high-precision-residuals-1"></a><a class="docs-heading-anchor-permalink" href="#IR-Krylov-with-high-precision-residuals" title="Permalink"></a></h2><p>Half precision factorizations can lead to failure in IR. IR-Krylov methods try to fix this by using the low precision factorization as a preconditioner, not a solver. <strong>MultiPrecisionArrays.jl</strong> has two IR-Krylov methods and one can adjust the residual precision just as one does with <code>mplu</code>. Here is an example of this using the two  multiprecision IR-Krylov factorizations <code>mpglu</code> (GMRES) and  <code>mpblu</code> (BiCGSTAB).</p><p>Using the same example, we examine the results.</p><pre><code class="nohighlight hljs">julia&gt; AF = mplu(A; TR=Float64);

julia&gt; mout16=\(AF, b; reporting=true);

julia&gt; mout16.rhist
4-element Vector{Float64}:
 9.88750e+01
 3.92451e+00
 3.34292e-01
 2.02204e-01</code></pre><p>so plain vanilla IR with <code>TF=Float16</code>, <code>TW=Float32</code>, and <code>TR=Float64</code> fails to converge. </p><p>We support both IR-GMRES and IR-BiCGSTAB for <code>TR &gt; TW</code>. You get this to work just like in {\tt mplu} by using the keyword argument {\tt TR}. We will continue with the example in this section and do that. For this example the default basis size of <span>$10$</span> is not enough, so we use 20.</p><pre><code class="nohighlight hljs">julia&gt; GF = mpglu(A; TR=Float64, basissize=20);

julia&gt; moutG = \(GF, b; reporting=true);

julia&gt; moutG.rhist
8-element Vector{Float64}:
 9.88750e+01
 7.59075e-03
 1.48842e-05
 2.17281e-07
 8.60429e-08
 7.45077e-08
 7.91866e-08
 7.53089e-08

julia&gt; moutG.dhist
7-element Vector{Float32}:
 1.03306e+00
 3.23734e-02
 2.83073e-04
 8.92629e-06
 1.55432e-07
 6.05685e-08
 5.96633e-08

julia&gt; xp = Float64.(A)\b;

julia&gt; norm(xp-moutG.sol, Inf)
5.95825e-08</code></pre><p>IR-BiCGSTAB would take fewer iterations than IR-GMRES had we used the default basis size because there&#39;s no storage issue. But remember that BiCGSTAB has a higher cost per linear iteration.</p><pre><code class="nohighlight hljs">julia&gt; BF = mpblu(A; TR=Float64);

julia&gt; moutB = \(BF, b; reporting=true);

julia&gt; moutB.rhist
5-element Vector{Float64}:
 9.88750e+01
 1.86437e-07
 7.53089e-08
 7.53089e-08
 7.53089e-08

julia&gt; moutB.dhist
4-element Vector{Float32}:
 1.00227e+00
 2.05457e-06
 5.95821e-08
 5.95821e-08

julia&gt; norm(xp - moutB.sol, Inf)
5.95825e-08</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Interprecision_1/">« Interprecision Transfers: Part I</a><a class="docs-footer-nextpage" href="../../functions/MPArray/">MPArray: constructor »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 26 July 2025 18:13">Saturday 26 July 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
